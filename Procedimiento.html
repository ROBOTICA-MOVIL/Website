<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Esdek Office Furniture(Digital Factory)</title>
        <link href="StylesNavBar.css" rel="stylesheet" type="text/css"> 
        <link href="Styles.css" rel="stylesheet" type="text/css">
        <script src="components/MyHeader.js" type="text/javascript" defer></script>
        <script src="components/footer.js" type="text/javascript" defer></script>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <div class="wrapper">
        <body class= "fondo">
            <header-custom></header-custom>

            <!--"Titulo de la sección"-->
            <h2>Desarrollo</h2>
            <h3> Metología </h3>
            <div> 
                <!--Texto-->
                <!--texto con estilo 'texto'-->
                <p class="texto2">
                  A continuación se muestra de manera general el paso a paso que se siguió para desarrollar este proyecto
                </p>
            </div>
           
            <div> 
                <!--Texto-->
                <!--texto con estilo 'texto'-->
                <p class="texto2" style="font-weight: bold;">Procedimiento:</p>
                <ul class="texto2">
                   <li> Indagar sobre la forma de establecer comunicación con el Lego EV3
                   <li> Reconocer conexiones y cables necesarios
                   <li> Crear y armar el laberinto 
                   <li> Posicionar y focalizar la cámara Kinect
                   <li> Identificar el origen del laberinto que reconoce la cámara
                   <li> Realizar el procesamiento de imágenes y comunicación
                   <li> Realizar pruebas
                </ul> 
                  <p class="texto2">
                    <a href="img/1.JPG?raw=true">
                    <img src="img/1.JPG?raw=true" width="50%" height="50%" alt="Red de comunicación" title="Red de comunicación" class="map">
                    </a>
                 </p>
            </div>
            <h3> Captura de información de la cámara </h3>
            <div>
             <div> 
                  <p class="texto2">
                Uso e identificación RGB de la imágen para filtrar y capturar objetos de un color especifico , para esto se desarrolla un código en Matlab que permite identificar la cámara Kinect y guardar la información que es capturada en la imágen, como el conjunto de datos corespondientes a los colores identificados y se guardan en un vector, seguido de esto se genera una imágen en escala de grises y se extraen los objetos de color azul, recordando que como se está usando la uinformación RGB que es captada, solo se pueden identificar objetos de color, rojo, verde y azul.
                </p>
                 <pre>
        <code>
            hwInfo = imaqhwinfo('kinect');
            hwInfo.DeviceInfo(1);
            hwInfo.DeviceInfo(2);
            colorVid = videoinput('kinect',1);
            depthVid = videoinput('kinect',2);
            colorvid.timeout=0.01;
            triggerconfig([colorVid depthVid],'manual');
            colorVid.FramesPerTrigger = 1;
            depthVid.FramesPerTrigger = 1;
            start([colorVid depthVid]);
            % Trigger the devices to start logging of data.
            trigger([colorVid depthVid]);
            % Retrieve the acquired data
            [colorFrameData,colorTimeData,colorMetaData] = getdata(colorVid);
            [depthFrameData,depthTimeData,depthMetaData] = getdata(depthVid);
            % Stop the devices
            %stop([colorVid depthVid]);
            % Pull out the 95th color frame
            img0=colorFrameData(:, :, :, 1);            
            img=imsubtract(img0(:,:,3),rgb2gray(img0)); 
        </code>
    </pre>
                <p class="texto2">
                Dado que las características del entorno son cambiantes como por ejemplo la iluminación del lugar el color de los objetos, es necesario aplicar un filtro para eliminar espacios en la parte interior de los objetos que reconoce así como eliminar los objetos menores a 1000 pixeles esto para evitar que se generen fantasmas por captar objetos duplicados.
                </p>
                   <pre>
        <code>
            bw=im2bw(img,0.13);                         % para binarizar la imagen
            bw=medfilt2(bw);                            % para aplicar un filtro 
            bw=imopen(bw,strel('disk',1));   
            bw=bwareaopen(bw,3000);                     %para eliminar los objetos menores a 3000 pixeles
            bw=imfill(bw, 'holes');                     % para eliminar los espacios dentro de los objetos que reconoce la camara
        </code>
    </pre>
                 <p class="texto2">
                Una vez identificados los objetos lo que nos interesa es su posición en el espacio captado por la cámara por lo que se le agregan una etiqueta a cada objeto identificado esto con el fin de contabilizar cuantos de ellos reconoce para después dibujar sobre ellos un rectangulo que los contenga e identificar el centroide, finalmente se muestra en pantalla las coordenadas que cada centroide tiene:
                </p>
                            <pre>
        <code>
                [L,N]=bwlabel(bw);                          % para agregar etiquetas a los objetos identificados, esto se guarda en la variable L, y en la variable N se guardan la cantidad de objetos idetificados
                prop=regionprops(L);                        % para obtener las propiedades de los elementos identificados
                imshow(img0);  % para mostrar las capturas
                for n=1:N
                    % las coordenadas del origen detectado por la camra corresponden a
                    % la esquina superior izquierda
                    c=round(prop(n).Centroid);             % para obtener el centroid
                    rectangle('Position', prop(n).BoundingBox,'EdgeColor','g','LineWidth',2)        % para hacer un rectangulo de color verde sobre el objeto
                    text(c(1),c(2),strcat('X:',num2str(c(1)),'Y:',num2str(c(2))),'Color','green');  % para agregar las coordenadas
                    xp(n)=c(1);
                    yp(n)=c(2);
                end
        </code>
    </pre>
                  <p class="texto2">
                    <a href="img/2.JPG?raw=true">
                    <img src="img/2.JPG?raw=true" width="50%" height="50%" alt="Origen del mapa" title="Origen del mapa" class="map">
                    </a>
                 </p>
                 <p class="texto2">
                Cabe resaltar que las coordenadas del origen detectado por la cámara corresponden a la esquina superior izquierda, por lo tanto si se quiere garantizar el mismo origen se debe dejar fija la cámara o en su defecto utilizar marcadores que indiquen la orientación y posición de la misma.
                </p>


                  </div>
            <h3> Mapa en MATLAB </h3>
                 <p class="texto2">
                Para crear el modelo digital del laberinto captado por la cámara se utilizó el software Autodesk Inventor en donde se cargó la imágen tomada por la cámara y se escalo a las dimensiones reales del laberinto, luego se copio la geometría y se guardo como una imagen png. Esta imágen se cargo a paint para ajustar los pixeles de la imágen, por último se desarrollo el siguiente código en Matlab para poder procesarlo como un mapa de ocupación binaria:
                </p>
                                     <pre>
        <code>
                %Cargar la imagen del laberinto y crear el mapa
                X=imread('laberinto.png','png');
                X=imresize(X,[240, 291]);
                X=X(:,:,1);
                min(min(X));
                max(max(X));
                Xb=X<128;
                mapa=binaryOccupancyMap(double(Xb),100);     % Para crear el mapa
                figure()
                show(mapa)
                grid on
        </code>
    </pre>

                <p class="texto2">
                    <a href="img/3.JPG?raw=true">
                    <img src="img/3.JPG?raw=true" width="50%" height="50%" alt="Mapa" title="Mapa" class="map">
                    </a>
                 </p>
                 <p class="texto2">
                Para evitar que el EV3 se choque con los diferentes obstáculos del laberinto se realiza el inflado del mapa utilizando el radio del robot:
                </p>
                                    <pre>
        <code>
               % Inflado de los obstaculos
                inflate(mapa,0.07)
                figure()
                show(mapa)
                grid on
        </code>
    </pre>

                <p class="texto2">
                    <a href="img/4.JPG?raw=true">
                    <img src="img/4.JPG?raw=true" width="50%" height="50%" alt="Mapa inflado" title="Mapa inflado" class="map">
                    </a>
                 </p>
                  <p class="texto2">
                Como lo que se busca es que el robot cumpla una misión se propone utilizar el algoritmo PRM para determinar la ruta que le permita realizar el recorrido dado un punto inicial y final:
                </p>
                                               <pre>
        <code>
               % Ruta 1
                pos_in=[2.6,0.2];          % Posicion inicial     
                pos_fin=[1.8,1.8];          % Posicion final    
                th=-pi;                   %[º] Orientacion del robot
                
                % Planeacion PRM  
                prm = robotics.PRM(mapa);
                prm.NumNodes = 300;
                prm.ConnectionDistance =10;
                path = findpath(prm, pos_in, pos_fin);
                figure()
                show(prm);
                grid on
        </code>
    </pre>

                <p class="texto2">
                    <a href="img/5.JPG?raw=true">
                    <img src="img/5.JPG?raw=true" width="50%" height="50%" alt="Ruta a seguir por el EV3" title="Ruta a seguir por el EV3" class="map">
                    </a>
                 </p> 
            
            <div>
                

                  </div>
            <h3> Localización del robot </h3>
                 <p class="texto2">
                Para la localización del robot en el laberinto se necesita conocer la posición y la orientación del robot, para esto se colocan tres marcadores del color de interés sobre el EV3 posicionados de tal forma que se forme un triángulo isóceles y el vértice que este más alejado corresponda al frente del robot:
                </p>
                <p class="texto2">
                    <a href="img/6.JPG?raw=true">
                    <img src="img/6.JPG?raw=true" width="30%" height="30%" alt="Indicadores para localización del EV3" title="Indicadores para localización del EV3" class="map">
                    </a>
                 </p>
                <p class="texto2">
                Por lo que se utilizan las coordenadas de los tres centroides identificados y se halla la distancia de cada uno de estos al lado formado por los otros dos, una vez determinadas estas distancias se busca la distancia mayor ya que esta corresponde a la ubicación de la cabeza del triángulo, luego se guardan las coordenadas de este centroide para después poder gráficarlos y compara con la ruta propuesta por el algortimo PRM:
                </p>
            <pre>
        <code>
            Points=[xp;yp];
            i=1;
            currentpoint=Points(:,i);
            distance=currentpoint-Points;
            d=diag(sqrt(distance'*distance));
            [row, col,outs]=find(d);
            error=max(outs)-min(outs);
            if error<5
                print('yes');
                head=Points(:,i);
                index=i;
            else
                print('not');
                head=Points(:,find(d==max(d)));
                index=find(d==max(d));
            end
            indices=[1 2 3];
            indices=find(indices~=index);
            vector_direction=head-(Points(:,indices(1))+Points(:,indices(2)))/2;
            or_cam=atan2(vector_direction(2)*(250/480),vector_direction(1)*(341/640));
            x_cam=head(1);
            y_cam=head(2);
            disp('--------------------------------------------------------------')
            disp('X    Y    Orientacion')
            disp([x_cam*(341/640) y_cam*(250/480) or_cam*180/pi])
            data_postura=[data_postura;[x_cam*(341/640) y_cam*(250/480) or_cam*180/pi]];
        </code>
    </pre>
                <p class="texto2">
                Es necesario recordar que la información que se extrae de la cámara esta en pixeles por lo que para poder conocer la localización real es necesario realizar una conversión a cm, para esto se tiene en cuenta las dimensiones reales del laberinto y la máxima cantidad de pixeles que mide la cámara:
                </p>
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>x</mi>
                    <mo>=</mo>
                    <mfrac>
                        <mrow>
                            <mo>-</mo>
                            <mi>b</mi>
                            <mo>&plusmn;</mo>
                            <msqrt>
                                <msup>
                                    <mi>b</mi>
                                    <mn>2</mn>
                                </msup>
                                <mo>-</mo>
                                <mn>4</mn>
                                <mo>&times;</mo>
                                <mi>a</mi>
                                <mo>&times;</mo>
                                <mi>c</mi>
                            </msqrt>
                        </mrow>
                        <mrow>
                            <mn>2</mn>
                            <mo>&times;</mo>
                            <mi>a</mi>
                        </mrow>
                    </mfrac>
                </math>
            <div>
            <h3> Conexión Lego EV3- Arduino </h3>
            <div> 
                <!--Texto-->
                <!--texto con estilo 'texto'-->
                <p class="texto2">
                sD
                </p>
            </div>        
        <footer>
            <footer-custom></footer-custom>
        </footer>
    </div>
</html>
    
